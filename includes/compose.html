<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
        <title>API Documentation</title>

        <link href="../stylesheets/screen.css" rel="stylesheet" type="text/css" media="screen" />
        <link href="../stylesheets/print.css" rel="stylesheet" type="text/css" media="print" />
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
            <script src="../javascripts/all_nosearch.js" type="text/javascript"></script>

    </head>

    <body class="includes includes_compose">
        <div id="main-header">
            <a href="http://docker.com">
                <img src="../images/small_h-dark-trans.png" />
                <div class="header-title">Documentation</div>
            </a>
        </div>
        <a href="#" id="nav-button">
            <span>
                NAV
                <img src="../images/navbar.png" />
            </span>
        </a>
        <div class="tocify-wrapper">
            <div id="toc">
            </div>
        </div>
        <div class="page-wrapper">
            <div class="dark-box"></div>
            <div class="content">
                <h1 id="docker-compose">Docker Compose</h1>

<p>Compose is a tool for defining and running multi-container applications with
Docker. With Compose, you define a multi-container application in a single
file, then spin your application up in a single command which does everything
that needs to be done to get it running.</p>

<p>Compose is great for development environments, staging servers, and CI. We don&rsquo;t
recommend that you use it in production yet.</p>

<p>Using Compose is basically a three-step process.</p>

<ol>
<li>Define your app&rsquo;s environment with a <code class="prettyprint">Dockerfile</code> so it can be
reproduced anywhere.</li>
<li>Define the services that make up your app in <code class="prettyprint">docker-compose.yml</code> so
they can be run together in an isolated environment:</li>
<li>Lastly, run <code class="prettyprint">docker-compose up</code> and Compose will start and run your entire app.</li>
</ol>

<blockquote>
<p>Example docker-compose.yml</p>
</blockquote>
<pre class="highlight plaintext"><code>web:
  build: .
  ports:
   - "5000:5000"
  volumes:
   - .:/code
  links:
   - redis
redis:
  image: redis
</code></pre>

<p>Compose has commands for managing the whole lifecycle of your application:</p>

<ul>
<li>Start, stop and rebuild services</li>
<li>View the status of running services</li>
<li>Stream the log output of running services</li>
<li>Run a one-off command on a service</li>
</ul>

<h2 id="quick-start">Quick start</h2>

<p>Let&rsquo;s get started with a walkthrough of getting a simple Python web app running
on Compose. It assumes a little knowledge of Python, but the concepts
demonstrated here should be understandable even if you&rsquo;re not familiar with
Python.</p>

<h3 id="installation-and-set-up">Installation and set-up</h3>

<p>First, <a href="install.md">install Docker and Compose</a>.</p>

<p>Next, you&rsquo;ll want to make a directory for the project:</p>

<p><code class="prettyprint">$ mkdir composetest</code>
<code class="prettyprint">$ cd composetest</code></p>

<p>Inside this directory, create <code class="prettyprint">app.py</code>, a simple web app that uses the Flask framework and increments a value in Redis. Don&rsquo;t worry if you don&rsquo;t have Redis installed, docker is going to take care of that for you when we <a href="#define-services">define services</a></p>

<blockquote>
<p>app.py</p>
</blockquote>
<pre class="highlight plaintext"><code>from flask import Flask
from redis import Redis

app = Flask(__name__)
redis = Redis(host='redis', port=6379)

@app.route('/')
def hello():
    redis.incr('hits')
    return 'Hello World! I have been seen %s times.' % redis.get('hits')

if __name__ == "__main__":
    app.run(host="0.0.0.0", debug=True)
</code></pre>

<p>Next, define the Python dependencies in a file called <code class="prettyprint">requirements.txt</code>:</p>

<blockquote>
<p>requirements.txt</p>
</blockquote>
<pre class="highlight plaintext"><code>flask
redis
</code></pre>

<h3 id="create-a-docker-image">Create a Docker image</h3>

<p>Now, create a Docker image containing all of your app&rsquo;s dependencies. You
specify how to build the image using a file called
<a href="http://docs.docker.com/reference/builder/"><code class="prettyprint">Dockerfile</code></a>:</p>

<blockquote>
<p>Dockerfile</p>
</blockquote>
<pre class="highlight plaintext"><code>FROM python:2.7
ADD . /code
WORKDIR /code
RUN pip install -r requirements.txt
CMD python app.py
</code></pre>

<p>This tells Docker to:</p>

<ul>
<li>Build an image starting with the Python 2.7 image.</li>
<li>Add the current directory <code class="prettyprint">.</code> into the path <code class="prettyprint">/code</code> in the image.</li>
<li>Set the working directory to <code class="prettyprint">/code</code>.</li>
<li>Install your Python dependencies.</li>
<li>Set the default command for the container to <code class="prettyprint">python app.py</code></li>
</ul>

<p>For more information on how to write Dockerfiles, see the <a href="https://docs.docker.com/userguide/dockerimages/#building-an-image-from-a-dockerfile">Docker user guide</a> and the <a href="http://docs.docker.com/reference/builder/">Dockerfile reference</a>.</p>

<p>You can test that this builds by running <code class="prettyprint">docker build -t web .</code>.</p>

<h3 id="define-services">Define services</h3>

<p>Next, define a set of services using <code class="prettyprint">docker-compose.yml</code>.</p>

<blockquote>
<p>docker-compose.yml</p>
</blockquote>
<pre class="highlight plaintext"><code>web:
  build: .
  ports:
   - "5000:5000"
  volumes:
   - .:/code
  links:
   - redis
redis:
  image: redis
</code></pre>

<p>This defines two services:</p>

<h4 id="web">web</h4>

<ul>
<li>Builds from the <code class="prettyprint">Dockerfile</code> in the current directory.</li>
<li>Forwards the exposed port 5000 on the container to port 5000 on the host machine.</li>
<li>Connects the web container to the Redis service via a link.</li>
<li>Mounts the current directory on the host to <code class="prettyprint">/code</code> inside the container allowing you to modify the code without having to rebuild the image.</li>
</ul>

<h4 id="redis">redis</h4>

<ul>
<li>Uses the public <a href="https://registry.hub.docker.com/_/redis/">Redis</a> image which gets pulled from the Docker Hub registry.</li>
</ul>

<h3 id="build-and-run-your-app-with-compose">Build and run your app with Compose</h3>

<p>Now, when you run <code class="prettyprint">docker-compose up</code>, Compose will pull a Redis image, build an image for your code, and start everything up:</p>

<blockquote>
<p>Example Output</p>
</blockquote>
<pre class="highlight plaintext"><code>$ docker-compose up
Pulling image redis...
Building web...
Starting composetest_redis_1...
Starting composetest_web_1...
redis_1 | [8] 02 Jan 18:43:35.576 # Server started, Redis version 2.8.3
web_1   |  * Running on http://0.0.0.0:5000/
web_1   |  * Restarting with stat
</code></pre>

<p>If you&rsquo;re using <a href="https://docs.docker.com/machine">Docker Machine</a>, then <code class="prettyprint">docker-machine ip MACHINE_VM</code> will tell you its address and you can open <code class="prettyprint">http://MACHINE_VM_IP:5000</code> in a browser.</p>

<p>If you&rsquo;re not using Boot2docker and are on linux, then the web app should now be listening on port 5000 on your Docker daemon host. If http://0.0.0.0:5000 doesn&rsquo;t resolve, you can also try localhost:5000.</p>

<p>You should get a message in your browser saying:</p>

<p><code class="prettyprint">Hello World! I have been seen 1 times.</code></p>

<p>Refreshing the page will increment the number.</p>

<p>If you want to run your services in the background, you can pass the <code class="prettyprint">-d</code> flag
(for &ldquo;detached&rdquo; mode) to <code class="prettyprint">docker-compose up</code> and use <code class="prettyprint">docker-compose ps</code> to
see what is currently running</p>

<blockquote>
<p>Example Output</p>
</blockquote>
<pre class="highlight plaintext"><code>$ docker-compose up -d
Starting composetest_redis_1...
Starting composetest_web_1...
$ docker-compose ps
    Name                 Command            State       Ports
-------------------------------------------------------------------
composetest_redis_1   /usr/local/bin/run         Up
composetest_web_1     /bin/sh -c python app.py   Up      5000-&gt;5000/tcp
</code></pre>

<p>The <code class="prettyprint">docker-compose run</code> command allows you to run one-off commands for your
services. For example, to see what environment variables are available to the
<code class="prettyprint">web</code> service:</p>

<p><code class="prettyprint">$ docker-compose run web env</code></p>

<p>See <code class="prettyprint">docker-compose --help</code> to see other available commands. You can also install <a href="completion.md">command completion</a> for the bash and zsh shell, which will also show you available commands.</p>

<p>If you started Compose with <code class="prettyprint">docker-compose up -d</code>, you&rsquo;ll probably want to stop
your services once you&rsquo;ve finished with them:</p>

<p><code class="prettyprint">$ docker-compose stop</code></p>

<p>At this point, you have seen the basics of how Compose works.</p>

            </div>
            <div class="dark-box">
            </div>
        </div>
    </body>
</html>
